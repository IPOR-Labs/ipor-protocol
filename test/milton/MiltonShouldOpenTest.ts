import hre from "hardhat";
import chai from "chai";
import { Signer, BigNumber } from "ethers";
import { MockSpreadModel } from "../../types";
import {
    N1__0_18DEC,
    N0__01_18DEC,
    USD_28_000_6DEC,
    ZERO,
    USD_10_18DEC,
    USD_28_000_18DEC,
    PERCENTAGE_3_18DEC,
    PERIOD_25_DAYS_IN_SECONDS,
    N0__1_18DEC,
    TC_OPENING_FEE_18DEC,
    TC_COLLATERAL_18DEC,
    TC_TOTAL_AMOUNT_10_000_18DEC,
    PERCENTAGE_4_18DEC,
    PERIOD_50_DAYS_IN_SECONDS,
	LEG_PAY_FIXED,
} from "../utils/Constants";
import {    
    prepareMockSpreadModel,
    MiltonUsdcCase,
    MiltonUsdtCase,
    MiltonDaiCase,
    testCaseWhenMiltonEarnAndUserLost,
} from "../utils/MiltonUtils";
import { openSwapPayFixed } from "../utils/SwapUtils";
import { MockStanleyCase } from "../utils/StanleyUtils";
import { JosephUsdcMockCases, JosephUsdtMockCases, JosephDaiMockCases } from "../utils/JosephUtils";

import {
    prepareComplexTestDataDaiCase000,
    getPayFixedDerivativeParamsDAICase1,
    getPayFixedDerivativeParamsUSDTCase1,
    prepareApproveForUsers,
    prepareTestData,
    setupTokenUsdtInitialValuesForUsers,
    setupTokenDaiInitialValuesForUsers,
} from "../utils/DataUtils";
import {
    assertError,
    assertExpectedValues,
    assertMiltonDerivativeItem,
} from "../utils/AssertUtils";

const { expect } = chai;

describe("Milton - Should Open", () => {
    let miltonSpreadModel: MockSpreadModel;
    let admin: Signer,
        userOne: Signer,
        userTwo: Signer,
        userThree: Signer,
        liquidityProvider: Signer;

    before(async () => {
        [admin, userOne, userTwo, userThree, liquidityProvider] = await hre.ethers.getSigners();
        miltonSpreadModel = await prepareMockSpreadModel(
            BigNumber.from("4").mul(N0__01_18DEC),
            ZERO,
            ZERO,
            ZERO
        );
    });

    it("should open pay fixed position - simple case DAI - 18 decimals", async () => {
        //given
        const testData = await prepareComplexTestDataDaiCase000(
            BigNumber.from(Math.floor(Date.now() / 1000)),
            [admin, userOne, userTwo, userThree, liquidityProvider],
            miltonSpreadModel,
            PERCENTAGE_3_18DEC
        );

        const { tokenDai, josephDai, miltonDai, iporOracle } = testData;

        if (tokenDai === undefined || josephDai === undefined || miltonDai === undefined) {
            expect(true).to.be.false;
            return;
        }

        const params = getPayFixedDerivativeParamsDAICase1(userTwo, tokenDai);

        const collateralWad = TC_COLLATERAL_18DEC;
        const openingFee = TC_OPENING_FEE_18DEC;

        await iporOracle
            .connect(userOne)
            .itfUpdateIndex(params.asset, PERCENTAGE_3_18DEC, params.openTimestamp);

        const miltonBalanceBeforePayoutWad = USD_28_000_18DEC;

        await josephDai
            .connect(liquidityProvider)
            .itfProvideLiquidity(miltonBalanceBeforePayoutWad, params.openTimestamp);

        const expectedMiltonUnderlyingTokenBalance = miltonBalanceBeforePayoutWad.add(
            params.totalAmount
        );
        const expectedLiquidityPoolTotalBalanceWad = miltonBalanceBeforePayoutWad.add(openingFee);
        const expectedDerivativesTotalBalanceWad = collateralWad;

        //when
        await miltonDai
            .connect(userTwo)
            .itfOpenSwapPayFixed(
                params.openTimestamp,
                params.totalAmount,
                params.acceptableFixedInterestRate,
                params.leverage
            );

        //then
        await assertExpectedValues(
            testData,
            params.asset,
            LEG_PAY_FIXED,
            userTwo,
            userTwo,
            miltonBalanceBeforePayoutWad,
            expectedMiltonUnderlyingTokenBalance,
            BigNumber.from("9990000").mul(N1__0_18DEC),
            BigNumber.from("9990000").mul(N1__0_18DEC),
            expectedLiquidityPoolTotalBalanceWad,
            BigNumber.from("1"),
            TC_COLLATERAL_18DEC,
            ZERO
        );

        const actualPayFixDerivativesBalanceWad = BigNumber.from(
            await (
                await miltonDai.getAccruedBalance()
            ).totalCollateralPayFixed
        );
        const actualRecFixDerivativesBalanceWad = BigNumber.from(
            await (
                await miltonDai.getAccruedBalance()
            ).totalCollateralReceiveFixed
        );
        const actualDerivativesTotalBalanceWad = actualPayFixDerivativesBalanceWad.add(
            actualRecFixDerivativesBalanceWad
        );

        expect(
            expectedDerivativesTotalBalanceWad,
            `Incorrect derivatives total balance for ${params.asset} actual ${actualDerivativesTotalBalanceWad}, expected ${expectedDerivativesTotalBalanceWad}Wad`
        ).to.be.eq(actualDerivativesTotalBalanceWad);
    });

    it("should open pay fixed position - simple case USDT - 6 decimals", async () => {
        //given
        const testData = await prepareTestData(
            BigNumber.from(Math.floor(Date.now() / 1000)),
            [admin, userOne, userTwo, userThree, liquidityProvider],
            ["USDT"],
            [PERCENTAGE_3_18DEC],
            miltonSpreadModel,
            MiltonUsdcCase.CASE0,
            MiltonUsdtCase.CASE0,
            MiltonDaiCase.CASE0,
            MockStanleyCase.CASE1,
            JosephUsdcMockCases.CASE0,
            JosephUsdtMockCases.CASE0,
            JosephDaiMockCases.CASE0
        );
        await prepareApproveForUsers(
            [userOne, userTwo, userThree, liquidityProvider],
            "USDT",
            testData
        );

        const { tokenUsdt, iporOracle, josephUsdt, miltonUsdt } = testData;

        if (tokenUsdt === undefined || josephUsdt === undefined || miltonUsdt === undefined) {
            expect(true).to.be.false;
            return;
        }

        await setupTokenUsdtInitialValuesForUsers(
            [admin, userOne, userTwo, userThree, liquidityProvider],
            tokenUsdt
        );
        const params = getPayFixedDerivativeParamsUSDTCase1(userTwo, tokenUsdt);

        const collateralWad = TC_COLLATERAL_18DEC;
        const openingFee = TC_OPENING_FEE_18DEC;

        await iporOracle
            .connect(userOne)
            .itfUpdateIndex(params.asset, PERCENTAGE_3_18DEC, params.openTimestamp);

        const miltonBalanceBeforePayout = USD_28_000_6DEC;
        const miltonBalanceBeforePayoutWad = USD_28_000_18DEC;

        await josephUsdt
            .connect(liquidityProvider)
            .itfProvideLiquidity(miltonBalanceBeforePayout, params.openTimestamp);

        const expectedMiltonUnderlyingTokenBalance = miltonBalanceBeforePayout.add(
            params.totalAmount
        );
        const expectedLiquidityPoolTotalBalanceWad = miltonBalanceBeforePayoutWad.add(openingFee);
        const expectedDerivativesTotalBalanceWad = collateralWad;

        //when
        await miltonUsdt
            .connect(userTwo)
            .itfOpenSwapPayFixed(
                params.openTimestamp,
                params.totalAmount,
                params.acceptableFixedInterestRate,
                params.leverage
            );

        //then
        await assertExpectedValues(
            testData,
            params.asset,
            LEG_PAY_FIXED,
            userTwo,
            userTwo,
            miltonBalanceBeforePayout,
            expectedMiltonUnderlyingTokenBalance,
            BigNumber.from("9990000000000"),
            BigNumber.from("9990000000000"),
            expectedLiquidityPoolTotalBalanceWad,
            BigNumber.from("1"),
            TC_COLLATERAL_18DEC,
            BigNumber.from("0")
        );
        const actualPayFixDerivativesBalanceWad = BigNumber.from(
            await (
                await miltonUsdt.getAccruedBalance()
            ).totalCollateralPayFixed
        );

        const actualRecFixDerivativesBalanceWad = BigNumber.from(
            await (
                await miltonUsdt.getAccruedBalance()
            ).totalCollateralReceiveFixed
        );

        const actualDerivativesTotalBalanceWad = actualPayFixDerivativesBalanceWad.add(
            actualRecFixDerivativesBalanceWad
        );

        expect(
            expectedDerivativesTotalBalanceWad,
            `Incorrect derivatives total balance for ${params.asset} actual ${actualDerivativesTotalBalanceWad}, expected ${expectedDerivativesTotalBalanceWad}Wad`
        ).to.be.eq(actualDerivativesTotalBalanceWad);
    });

    it("should open pay fixed position, DAI, custom Opening Fee for Treasury 50%", async () => {
        //given
        const testData = await prepareTestData(
            BigNumber.from(Math.floor(Date.now() / 1000)),
            [admin, userOne, userTwo, userThree, liquidityProvider],
            ["DAI"],
            [PERCENTAGE_3_18DEC],
            miltonSpreadModel,
            MiltonUsdcCase.CASE4,
            MiltonUsdtCase.CASE4,
            MiltonDaiCase.CASE4,
            MockStanleyCase.CASE1,
            JosephUsdcMockCases.CASE0,
            JosephUsdtMockCases.CASE0,
            JosephDaiMockCases.CASE0
        );

        const { tokenDai, iporOracle, josephDai, miltonDai, miltonStorageDai } = testData;

        if (
            tokenDai === undefined ||
            josephDai === undefined ||
            miltonDai === undefined ||
            miltonStorageDai === undefined
        ) {
            expect(true).to.be.false;
            return;
        }

        await prepareApproveForUsers(
            [userOne, userTwo, userThree, liquidityProvider],
            "DAI",
            testData
        );
        await setupTokenDaiInitialValuesForUsers(
            [admin, userOne, userTwo, userThree, liquidityProvider],
            testData
        );
        const params = getPayFixedDerivativeParamsDAICase1(userTwo, tokenDai);

        await iporOracle
            .connect(userOne)
            .itfUpdateIndex(params.asset, PERCENTAGE_3_18DEC, params.openTimestamp);

        const expectedTreasuryTotalBalanceWad = BigNumber.from("149505148455463361");

        const miltonBalanceBeforePayoutWad = USD_28_000_18DEC;
        const expectedLiquidityPoolTotalBalanceWad = BigNumber.from("28002840597820653803859");

        await josephDai
            .connect(liquidityProvider)
            .itfProvideLiquidity(miltonBalanceBeforePayoutWad, params.openTimestamp);

        //when
        await miltonDai
            .connect(userTwo)
            .itfOpenSwapPayFixed(
                params.openTimestamp,
                params.totalAmount,
                params.acceptableFixedInterestRate,
                params.leverage
            );

        //then
        const balance = await miltonStorageDai.getExtendedBalance();

        const actualLiquidityPoolTotalBalanceWad = BigNumber.from(balance.liquidityPool);
        const actualTreasuryTotalBalanceWad = BigNumber.from(balance.treasury);

        expect(
            expectedLiquidityPoolTotalBalanceWad,
            `Incorrect Liquidity Pool total balance for ${params.asset}, actual:  ${actualLiquidityPoolTotalBalanceWad},
            expected: ${expectedLiquidityPoolTotalBalanceWad}`
        ).to.be.eq(actualLiquidityPoolTotalBalanceWad);
        expect(
            expectedTreasuryTotalBalanceWad,
            `Incorrect Treasury total balance for ${params.asset}, actual:  ${actualTreasuryTotalBalanceWad},
            expected: ${expectedTreasuryTotalBalanceWad}`
        ).to.be.eq(actualTreasuryTotalBalanceWad);
    });

    it("should open pay fixed position, DAI, custom Opening Fee for Treasury 25%", async () => {
        //given
        const testData = await prepareTestData(
            BigNumber.from(Math.floor(Date.now() / 1000)),
            [admin, userOne, userTwo, userThree, liquidityProvider],
            ["DAI"],
            [PERCENTAGE_3_18DEC],
            miltonSpreadModel,
            MiltonUsdcCase.CASE5,
            MiltonUsdtCase.CASE5,
            MiltonDaiCase.CASE5,
            MockStanleyCase.CASE1,
            JosephUsdcMockCases.CASE0,
            JosephUsdtMockCases.CASE0,
            JosephDaiMockCases.CASE0
        );

        await prepareApproveForUsers(
            [userOne, userTwo, userThree, liquidityProvider],
            "DAI",
            testData
        );

        const { tokenDai, iporOracle, josephDai, miltonDai, miltonStorageDai } = testData;

        if (
            tokenDai === undefined ||
            josephDai === undefined ||
            miltonDai === undefined ||
            miltonStorageDai === undefined
        ) {
            expect(true).to.be.false;
            return;
        }

        await setupTokenDaiInitialValuesForUsers(
            [admin, userOne, userTwo, userThree, liquidityProvider],
            testData
        );
        const params = getPayFixedDerivativeParamsDAICase1(userTwo, tokenDai);

        await iporOracle
            .connect(userOne)
            .itfUpdateIndex(params.asset, PERCENTAGE_3_18DEC, params.openTimestamp);

        const expectedTreasuryTotalBalanceWad = BigNumber.from("74752574227731681");

        const miltonBalanceBeforePayoutWad = USD_28_000_18DEC;
        const expectedLiquidityPoolTotalBalanceWad = BigNumber.from("28002915350394881535539");
        await josephDai
            .connect(liquidityProvider)
            .itfProvideLiquidity(miltonBalanceBeforePayoutWad, params.openTimestamp);

        //when
        await miltonDai
            .connect(userTwo)
            .itfOpenSwapPayFixed(
                params.openTimestamp,
                params.totalAmount,
                params.acceptableFixedInterestRate,
                params.leverage
            );

        //then
        const balance = await miltonStorageDai.getExtendedBalance();

        const actualLiquidityPoolTotalBalanceWad = BigNumber.from(balance.liquidityPool);
        const actualTreasuryTotalBalanceWad = BigNumber.from(balance.treasury);

        expect(
            expectedLiquidityPoolTotalBalanceWad,
            `Incorrect Liquidity Pool total balance for ${params.asset}, actual:  ${actualLiquidityPoolTotalBalanceWad},
            expected: ${expectedLiquidityPoolTotalBalanceWad}`
        ).to.be.eq(actualLiquidityPoolTotalBalanceWad);
        expect(
            expectedTreasuryTotalBalanceWad,
            `Incorrect Treasury total balance for ${params.asset}, actual:  ${actualTreasuryTotalBalanceWad},
            expected: ${expectedTreasuryTotalBalanceWad}`
        ).to.be.eq(actualTreasuryTotalBalanceWad);
    });

    it("should open pay fixed position, DAI, custom leverage - simple case 1", async () => {
        //given
        const testData = await prepareComplexTestDataDaiCase000(
            BigNumber.from(Math.floor(Date.now() / 1000)),
            [admin, userOne, userTwo, userThree, liquidityProvider],
            miltonSpreadModel,
            PERCENTAGE_3_18DEC
        );

        const { tokenDai, iporOracle, josephDai, miltonDai, miltonStorageDai } = testData;

        if (
            tokenDai === undefined ||
            josephDai === undefined ||
            miltonDai === undefined ||
            miltonStorageDai === undefined
        ) {
            expect(true).to.be.false;
            return;
        }

        const params = {
            asset: tokenDai,
            totalAmount: TC_TOTAL_AMOUNT_10_000_18DEC,
            acceptableFixedInterestRate: BigNumber.from("9").mul(N0__1_18DEC),
            leverage: BigNumber.from("15125000000000000000"),
            openTimestamp: BigNumber.from(Math.floor(Date.now() / 1000)),
            from: userTwo,
        };
        await iporOracle
            .connect(userOne)
            .itfUpdateIndex(params.asset.address, PERCENTAGE_3_18DEC, params.openTimestamp);

        await josephDai
            .connect(liquidityProvider)
            .itfProvideLiquidity(USD_28_000_18DEC, params.openTimestamp);

        //when
        await miltonDai
            .connect(userTwo)
            .itfOpenSwapPayFixed(
                params.openTimestamp,
                params.totalAmount,
                params.acceptableFixedInterestRate,
                params.leverage
            );

        //then
        const actualDerivativeItem = await miltonStorageDai.getSwapPayFixed(1);
        const actualNotionalAmount = BigNumber.from(actualDerivativeItem.notional);
        const expectedNotionalAmount = BigNumber.from("150751024692592222333298");

        expect(
            expectedNotionalAmount,
            `Incorrect notional amount for ${params.asset}, actual:  ${actualNotionalAmount},
            expected: ${expectedNotionalAmount}`
        ).to.be.eq(actualNotionalAmount);
    });

    it("should open pay fixed position - when open timestamp is long time ago", async () => {
        //given
        const veryLongTimeAgoTimestamp = BigNumber.from("31536000"); //1971-01-01
        const testData = await prepareComplexTestDataDaiCase000(
            veryLongTimeAgoTimestamp,
            [admin, userOne, userTwo, userThree, liquidityProvider],
            miltonSpreadModel,
            PERCENTAGE_3_18DEC
        );
        const { tokenDai } = testData;
        if (tokenDai === undefined) {
            expect(true).to.be.false;
            return;
        }

        const expectedIncomeFeeValueWad = ZERO;
        const expectedPayoff = ZERO;
        const expectedPayoffWad = ZERO;

        await testCaseWhenMiltonEarnAndUserLost(
            testData,
            tokenDai.address,
            USD_10_18DEC,
            LEG_PAY_FIXED,
            userTwo,
            userTwo,
            PERCENTAGE_3_18DEC,
            PERCENTAGE_4_18DEC,
            ZERO,
            ZERO,
            ZERO,
            expectedIncomeFeeValueWad,
            ZERO,
            BigNumber.from(veryLongTimeAgoTimestamp),
            expectedIncomeFeeValueWad,
            expectedPayoff,
            expectedPayoffWad,
            userOne,
            liquidityProvider
        );
    });

    it("should open many positions and arrays with ids have correct state, one user", async () => {
        //given
        const testData = await prepareComplexTestDataDaiCase000(
            BigNumber.from(Math.floor(Date.now() / 1000)),
            [admin, userOne, userTwo, userThree, liquidityProvider],
            miltonSpreadModel,
            PERCENTAGE_3_18DEC
        );

        const { tokenDai, josephDai, iporOracle, miltonDai, miltonStorageDai } = testData;
        if (
            tokenDai === undefined ||
            josephDai === undefined ||
            miltonDai === undefined ||
            miltonStorageDai === undefined
        ) {
            expect(true).to.be.false;
            return;
        }

        const openerUser = userTwo;
        const iporValueBeforeOpenSwap = PERCENTAGE_3_18DEC;
        const openTimestamp = BigNumber.from(Math.floor(Date.now() / 1000));

        const derivativeParams = {
            asset: tokenDai.address,
            totalAmount: TC_TOTAL_AMOUNT_10_000_18DEC,
            acceptableFixedInterestRate: BigNumber.from("9").mul(N0__1_18DEC),
            leverage: USD_10_18DEC,
            openTimestamp: openTimestamp,
            from: openerUser,
        };
        await iporOracle
            .connect(userOne)
            .itfUpdateIndex(
                derivativeParams.asset,
                iporValueBeforeOpenSwap,
                derivativeParams.openTimestamp
            );

        const expectedUserDerivativeIdsLength = 3;

        await josephDai
            .connect(liquidityProvider)
            .itfProvideLiquidity(
                BigNumber.from(3).mul(USD_28_000_18DEC),
                derivativeParams.openTimestamp
            );

        //when
        await openSwapPayFixed(testData, derivativeParams);
        derivativeParams.openTimestamp =
            derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS);
        await openSwapPayFixed(testData, derivativeParams);
        derivativeParams.openTimestamp =
            derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS);
        await openSwapPayFixed(testData, derivativeParams);

        //then
        const actualUserDerivativeResponse = await miltonStorageDai.getSwapPayFixedIds(
            await userTwo.getAddress(),
            0,
            10
        );
        const actualUserDerivativeIds = actualUserDerivativeResponse.ids;

        expect(
            expectedUserDerivativeIdsLength,
            `Incorrect user swap ids length actual: ${actualUserDerivativeIds.length}, expected: ${expectedUserDerivativeIdsLength}`
        ).to.be.eq(actualUserDerivativeIds.length);

        await assertMiltonDerivativeItem(testData, derivativeParams.asset, 1, 0, 0, 0);
        await assertMiltonDerivativeItem(testData, derivativeParams.asset, 2, 0, 1, 1);
        await assertMiltonDerivativeItem(testData, derivativeParams.asset, 3, 0, 2, 2);
    });

    it("should open many positions and arrays with ids have correct state, two users", async () => {
        //given
        const testData = await prepareComplexTestDataDaiCase000(
            BigNumber.from(Math.floor(Date.now() / 1000)),
            [admin, userOne, userTwo, userThree, liquidityProvider],
            miltonSpreadModel,
            PERCENTAGE_3_18DEC
        );

        const { tokenDai, josephDai, iporOracle, miltonDai, miltonStorageDai } = testData;
        if (
            tokenDai === undefined ||
            josephDai === undefined ||
            miltonDai === undefined ||
            miltonStorageDai === undefined
        ) {
            expect(true).to.be.false;
            return;
        }

        const iporValueBeforeOpenSwap = PERCENTAGE_3_18DEC;
        const openTimestamp = BigNumber.from(Math.floor(Date.now() / 1000));

        const derivativeParams = {
            asset: tokenDai.address,
            totalAmount: TC_TOTAL_AMOUNT_10_000_18DEC,
            acceptableFixedInterestRate: BigNumber.from("9").mul(N0__1_18DEC),
            leverage: USD_10_18DEC,
            openTimestamp: openTimestamp,
            from: userTwo,
        };
        await iporOracle
            .connect(userOne)
            .itfUpdateIndex(
                derivativeParams.asset,
                iporValueBeforeOpenSwap,
                derivativeParams.openTimestamp
            );

        const expectedUserDerivativeIdsLengthFirst = 2;
        const expectedUserDerivativeIdsLengthSecond = 1;

        await josephDai
            .connect(liquidityProvider)
            .itfProvideLiquidity(
                BigNumber.from(3).mul(USD_28_000_18DEC),
                derivativeParams.openTimestamp
            );

        //when
        await openSwapPayFixed(testData, derivativeParams);

        derivativeParams.openTimestamp =
            derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS);
        derivativeParams.from = userThree;
        await openSwapPayFixed(testData, derivativeParams);

        derivativeParams.openTimestamp =
            derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS);
        derivativeParams.from = userTwo;
        await openSwapPayFixed(testData, derivativeParams);

        //then
        const actualUserDerivativeResponseFirst = await miltonStorageDai.getSwapPayFixedIds(
            await userTwo.getAddress(),
            0,
            10
        );
        const actualUserDerivativeIdsFirst = actualUserDerivativeResponseFirst.ids;
        const actualUserDerivativeResponseSecond = await miltonStorageDai.getSwapPayFixedIds(
            await userThree.getAddress(),
            0,
            10
        );
        const actualUserDerivativeIdsSecond = actualUserDerivativeResponseSecond.ids;

        expect(
            expectedUserDerivativeIdsLengthFirst,
            `Incorrect first user swap ids length actual: ${actualUserDerivativeIdsFirst.length}, expected: ${expectedUserDerivativeIdsLengthFirst}`
        ).to.be.eq(actualUserDerivativeIdsFirst.length);
        expect(
            expectedUserDerivativeIdsLengthSecond,
            `Incorrect second user swap ids length actual: ${actualUserDerivativeIdsSecond.length}, expected: ${expectedUserDerivativeIdsLengthSecond}`
        ).to.be.eq(actualUserDerivativeIdsSecond.length);

        await assertMiltonDerivativeItem(testData, derivativeParams.asset, 1, 0, 0, 0);
        await assertMiltonDerivativeItem(testData, derivativeParams.asset, 2, 0, 1, 0);
        await assertMiltonDerivativeItem(testData, derivativeParams.asset, 3, 0, 2, 1);
    });

    it("should open many positions and close one position and arrays with ids have correct state, two users", async () => {
        //given
        const testData = await prepareComplexTestDataDaiCase000(
            BigNumber.from(Math.floor(Date.now() / 1000)),
            [admin, userOne, userTwo, userThree, liquidityProvider],
            miltonSpreadModel,
            PERCENTAGE_3_18DEC
        );

        const iporValueBeforeOpenSwap = PERCENTAGE_3_18DEC;
        const openTimestamp = BigNumber.from(Math.floor(Date.now() / 1000));

        const { tokenDai, josephDai, iporOracle, miltonDai, miltonStorageDai } = testData;
        if (
            tokenDai === undefined ||
            josephDai === undefined ||
            miltonDai === undefined ||
            miltonStorageDai === undefined
        ) {
            expect(true).to.be.false;
            return;
        }

        const derivativeParams = {
            asset: tokenDai.address,
            totalAmount: TC_TOTAL_AMOUNT_10_000_18DEC,
            acceptableFixedInterestRate: BigNumber.from("9").mul(N0__1_18DEC),
            leverage: USD_10_18DEC,
            openTimestamp: openTimestamp,
            from: userTwo,
        };
        await iporOracle
            .connect(userOne)
            .itfUpdateIndex(
                derivativeParams.asset,
                iporValueBeforeOpenSwap,
                derivativeParams.openTimestamp
            );

        const expectedUserDerivativeIdsLengthFirst = 2;
        const expectedUserDerivativeIdsLengthSecond = 0;

        await josephDai
            .connect(liquidityProvider)
            .itfProvideLiquidity(
                BigNumber.from(3).mul(USD_28_000_18DEC),
                derivativeParams.openTimestamp
            );

        await openSwapPayFixed(testData, derivativeParams);

        derivativeParams.openTimestamp =
            derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS);
        derivativeParams.from = userThree;
        await openSwapPayFixed(testData, derivativeParams);

        derivativeParams.openTimestamp =
            derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS);
        derivativeParams.from = userTwo;
        await openSwapPayFixed(testData, derivativeParams);

        //when
        await miltonDai
            .connect(userThree)
            .itfCloseSwapPayFixed(2, derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS));

        //then
        const actualUserDerivativeResponseFirst = await miltonStorageDai.getSwapPayFixedIds(
            await userTwo.getAddress(),
            0,
            10
        );
        const actualUserDerivativeIdsFirst = actualUserDerivativeResponseFirst.ids;
        const actualUserDerivativeResponseSecond = await miltonStorageDai.getSwapPayFixedIds(
            await userThree.getAddress(),
            0,
            10
        );
        const actualUserDerivativeIdsSecond = actualUserDerivativeResponseSecond.ids;

        expect(
            expectedUserDerivativeIdsLengthFirst,
            `Incorrect first user swap ids length actual: ${actualUserDerivativeIdsFirst.length}, expected: ${expectedUserDerivativeIdsLengthFirst}`
        ).to.be.eq(actualUserDerivativeIdsFirst.length);
        expect(
            expectedUserDerivativeIdsLengthSecond,
            `Incorrect second user swap ids length actual: ${actualUserDerivativeIdsSecond.length}, expected: ${expectedUserDerivativeIdsLengthSecond}`
        ).to.be.eq(actualUserDerivativeIdsSecond.length);

        await assertMiltonDerivativeItem(testData, derivativeParams.asset, 1, 0, 0, 0);
        await assertMiltonDerivativeItem(testData, derivativeParams.asset, 3, 0, 1, 1);
    });

    it("should open many positions and close two positions and arrays with ids have correct state, two users", async () => {
        //given
        const testData = await prepareComplexTestDataDaiCase000(
            BigNumber.from(Math.floor(Date.now() / 1000)),
            [admin, userOne, userTwo, userThree, liquidityProvider],
            miltonSpreadModel,
            PERCENTAGE_3_18DEC
        );

        const { tokenDai, josephDai, iporOracle, miltonDai, miltonStorageDai } = testData;
        if (
            tokenDai === undefined ||
            josephDai === undefined ||
            miltonDai === undefined ||
            miltonStorageDai === undefined
        ) {
            expect(true).to.be.false;
            return;
        }

        const iporValueBeforeOpenSwap = PERCENTAGE_3_18DEC;
        const openTimestamp = BigNumber.from(Math.floor(Date.now() / 1000));

        const derivativeParams = {
            asset: tokenDai.address,
            totalAmount: TC_TOTAL_AMOUNT_10_000_18DEC,
            acceptableFixedInterestRate: BigNumber.from("9").mul(N0__1_18DEC),
            leverage: USD_10_18DEC,
            openTimestamp: openTimestamp,
            from: userTwo,
        };
        await iporOracle
            .connect(userOne)
            .itfUpdateIndex(
                derivativeParams.asset,
                iporValueBeforeOpenSwap,
                derivativeParams.openTimestamp
            );

        const expectedUserDerivativeIdsLengthFirst = 1;
        const expectedUserDerivativeIdsLengthSecond = 0;

        await josephDai
            .connect(liquidityProvider)
            .itfProvideLiquidity(
                BigNumber.from(3).mul(USD_28_000_18DEC),
                derivativeParams.openTimestamp
            );

        await openSwapPayFixed(testData, derivativeParams);

        derivativeParams.openTimestamp =
            derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS);
        derivativeParams.from = userThree;
        await openSwapPayFixed(testData, derivativeParams);

        derivativeParams.openTimestamp =
            derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS);
        derivativeParams.from = userTwo;
        await openSwapPayFixed(testData, derivativeParams);

        //when
        await miltonDai
            .connect(userThree)
            .itfCloseSwapPayFixed(2, derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS));
        await miltonDai
            .connect(userTwo)
            .itfCloseSwapPayFixed(3, derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS));

        //then
        const actualUserDerivativeResponseFirst = await miltonStorageDai.getSwapPayFixedIds(
            await userTwo.getAddress(),
            0,
            10
        );
        const actualUserDerivativeIdsFirst = actualUserDerivativeResponseFirst.ids;
        const actualUserDerivativeResponseSecond = await miltonStorageDai.getSwapPayFixedIds(
            await userThree.getAddress(),
            0,
            10
        );
        const actualUserDerivativeIdsSecond = actualUserDerivativeResponseSecond.ids;

        expect(
            expectedUserDerivativeIdsLengthFirst,
            `Incorrect first user swap ids length actual: ${actualUserDerivativeIdsFirst.length}, expected: ${expectedUserDerivativeIdsLengthFirst}`
        ).to.be.eq(actualUserDerivativeIdsFirst.length);
        expect(
            expectedUserDerivativeIdsLengthSecond,
            `Incorrect second user swap ids length actual: ${actualUserDerivativeIdsSecond.length}, expected: ${expectedUserDerivativeIdsLengthSecond}`
        ).to.be.eq(actualUserDerivativeIdsSecond.length);

        await assertMiltonDerivativeItem(testData, derivativeParams.asset, 1, 0, 0, 0);
    });

    it("should open two positions and close two positions - Arithmetic overflow - fix last byte difference - case 1", async () => {
        //given
        const testData = await prepareComplexTestDataDaiCase000(
            BigNumber.from(Math.floor(Date.now() / 1000)),
            [admin, userOne, userTwo, userThree, liquidityProvider],
            miltonSpreadModel,
            PERCENTAGE_3_18DEC
        );

        const { tokenDai, josephDai, iporOracle, miltonDai, miltonStorageDai } = testData;
        if (
            tokenDai === undefined ||
            josephDai === undefined ||
            miltonDai === undefined ||
            miltonStorageDai === undefined
        ) {
            expect(true).to.be.false;
            return;
        }

        const iporValueBeforeOpenSwap = PERCENTAGE_3_18DEC;
        const openTimestamp = BigNumber.from(Math.floor(Date.now() / 1000));

        const derivativeParams = {
            asset: tokenDai.address,
            totalAmount: TC_TOTAL_AMOUNT_10_000_18DEC,
            acceptableFixedInterestRate: BigNumber.from("9").mul(N0__1_18DEC),
            leverage: USD_10_18DEC,
            openTimestamp: openTimestamp,
            from: userThree,
        };
        await josephDai
            .connect(liquidityProvider)
            .itfProvideLiquidity(
                BigNumber.from(2).mul(USD_28_000_18DEC),
                derivativeParams.openTimestamp
            );
        await iporOracle
            .connect(userOne)
            .itfUpdateIndex(
                derivativeParams.asset,
                iporValueBeforeOpenSwap,
                derivativeParams.openTimestamp
            );

        const expectedUserDerivativeIdsLengthFirst = 0;
        const expectedUserDerivativeIdsLengthSecond = 0;

        //position 1, user first
        await openSwapPayFixed(testData, derivativeParams);

        //position 2, user second
        derivativeParams.openTimestamp =
            derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS);
        await openSwapPayFixed(testData, derivativeParams);

        //when
        await miltonDai
            .connect(userThree)
            .itfCloseSwapPayFixed(1, derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS));
        await miltonDai
            .connect(userThree)
            .itfCloseSwapPayFixed(2, derivativeParams.openTimestamp.add(PERIOD_50_DAYS_IN_SECONDS));

        //then
        const actualUserDerivativeResponseFirst = await miltonStorageDai.getSwapPayFixedIds(
            await userTwo.getAddress(),
            0,
            10
        );
        const actualUserDerivativeIdsFirst = actualUserDerivativeResponseFirst.ids;
        const actualUserDerivativeResponseSecond = await miltonStorageDai.getSwapPayFixedIds(
            await userThree.getAddress(),
            0,
            10
        );
        const actualUserDerivativeIdsSecond = actualUserDerivativeResponseSecond.ids;

        expect(
            expectedUserDerivativeIdsLengthFirst,
            `Incorrect first user swap ids length actual: ${actualUserDerivativeIdsFirst.length}, expected: ${expectedUserDerivativeIdsLengthFirst}`
        ).to.be.eq(actualUserDerivativeIdsFirst.length);
        expect(
            expectedUserDerivativeIdsLengthSecond,
            `Incorrect second user swap ids length actual: ${actualUserDerivativeIdsSecond.length}, expected: ${expectedUserDerivativeIdsLengthSecond}`
        ).to.be.eq(actualUserDerivativeIdsSecond.length);
    });

    it("should open two positions and close two positions - Arithmetic overflow - fix last byte difference - case 1 with minus 3", async () => {
        //given
        const testData = await prepareComplexTestDataDaiCase000(
            BigNumber.from(Math.floor(Date.now() / 1000)),
            [admin, userOne, userTwo, userThree, liquidityProvider],
            miltonSpreadModel,
            PERCENTAGE_3_18DEC
        );

        const { tokenDai, josephDai, iporOracle, miltonDai, miltonStorageDai } = testData;
        if (
            tokenDai === undefined ||
            josephDai === undefined ||
            miltonDai === undefined ||
            miltonStorageDai === undefined
        ) {
            expect(true).to.be.false;
            return;
        }

        const iporValueBeforeOpenSwap = PERCENTAGE_3_18DEC;
        const openTimestamp = BigNumber.from(Math.floor(Date.now() / 1000));

        const derivativeParams = {
            asset: tokenDai.address,
            totalAmount: TC_TOTAL_AMOUNT_10_000_18DEC,
            acceptableFixedInterestRate: BigNumber.from("9").mul(N0__1_18DEC),
            leverage: USD_10_18DEC,
            openTimestamp: openTimestamp,
            from: userThree,
        };
        await josephDai
            .connect(liquidityProvider)
            .itfProvideLiquidity(
                BigNumber.from(2).mul(USD_28_000_18DEC),
                derivativeParams.openTimestamp
            );
        await iporOracle
            .connect(userOne)
            .itfUpdateIndex(
                derivativeParams.asset,
                iporValueBeforeOpenSwap,
                derivativeParams.openTimestamp
            );

        const expectedUserDerivativeIdsLengthFirst = 0;
        const expectedUserDerivativeIdsLengthSecond = 0;

        //position 1, user first
        await openSwapPayFixed(testData, derivativeParams);

        //position 2, user second
        derivativeParams.openTimestamp = derivativeParams.openTimestamp
            .add(PERIOD_25_DAYS_IN_SECONDS)
            .sub(BigNumber.from("3"));
        await openSwapPayFixed(testData, derivativeParams);

        //when
        await miltonDai
            .connect(userThree)
            .itfCloseSwapPayFixed(1, derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS));
        await miltonDai
            .connect(userThree)
            .itfCloseSwapPayFixed(2, derivativeParams.openTimestamp.add(PERIOD_50_DAYS_IN_SECONDS));

        //then
        const actualUserDerivativeResponseFirst = await miltonStorageDai.getSwapPayFixedIds(
            await userTwo.getAddress(),
            0,
            10
        );
        const actualUserDerivativeIdsFirst = actualUserDerivativeResponseFirst.ids;
        const actualUserDerivativeResponseSecond = await miltonStorageDai.getSwapPayFixedIds(
            await userThree.getAddress(),
            0,
            10
        );
        const actualUserDerivativeIdsSecond = actualUserDerivativeResponseSecond.ids;

        expect(
            expectedUserDerivativeIdsLengthFirst,
            `Incorrect first user swap ids length actual: ${actualUserDerivativeIdsFirst.length}, expected: ${expectedUserDerivativeIdsLengthFirst}`
        ).to.be.eq(actualUserDerivativeIdsFirst.length);
        expect(
            expectedUserDerivativeIdsLengthSecond,
            `Incorrect second user swap ids length actual: ${actualUserDerivativeIdsSecond.length}, expected: ${expectedUserDerivativeIdsLengthSecond}`
        ).to.be.eq(actualUserDerivativeIdsSecond.length);
    });

    it("should open two positions and close one position - Arithmetic overflow - last byte difference - case 1", async () => {
        //given
        const testData = await prepareComplexTestDataDaiCase000(
            BigNumber.from(Math.floor(Date.now() / 1000)),
            [admin, userOne, userTwo, userThree, liquidityProvider],
            miltonSpreadModel,
            PERCENTAGE_3_18DEC
        );
        const { tokenDai, josephDai, iporOracle, miltonDai, miltonStorageDai } = testData;
        if (
            tokenDai === undefined ||
            josephDai === undefined ||
            miltonDai === undefined ||
            miltonStorageDai === undefined
        ) {
            expect(true).to.be.false;
            return;
        }

        const iporValueBeforeOpenSwap = PERCENTAGE_3_18DEC;
        const openTimestamp = BigNumber.from(Math.floor(Date.now() / 1000));

        const derivativeParams = {
            asset: tokenDai.address,
            totalAmount: TC_TOTAL_AMOUNT_10_000_18DEC,
            acceptableFixedInterestRate: BigNumber.from("9").mul(N0__1_18DEC),
            leverage: USD_10_18DEC,
            openTimestamp: openTimestamp,
            from: userThree,
        };
        await josephDai
            .connect(liquidityProvider)
            .itfProvideLiquidity(
                BigNumber.from(2).mul(USD_28_000_18DEC),
                derivativeParams.openTimestamp
            );
        await iporOracle
            .connect(userOne)
            .itfUpdateIndex(
                derivativeParams.asset,
                iporValueBeforeOpenSwap,
                derivativeParams.openTimestamp
            );

        const expectedUserDerivativeIdsLengthFirst = 0;
        const expectedUserDerivativeIdsLengthSecond = 0;

        //position 1, user first
        derivativeParams.from = userThree;
        await openSwapPayFixed(testData, derivativeParams);

        //position 2, user second
        derivativeParams.openTimestamp =
            derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS);
        derivativeParams.from = userThree;
        await openSwapPayFixed(testData, derivativeParams);

        await miltonDai
            .connect(userThree)
            .itfCloseSwapPayFixed(1, derivativeParams.openTimestamp.add(PERIOD_25_DAYS_IN_SECONDS));

        //when
        await miltonDai
            .connect(userThree)
            .itfCloseSwapPayFixed(2, derivativeParams.openTimestamp.add(PERIOD_50_DAYS_IN_SECONDS));

        //then
        const actualUserDerivativeResponseFirst = await miltonStorageDai.getSwapPayFixedIds(
            await userTwo.getAddress(),
            0,
            10
        );
        const actualUserDerivativeIdsFirst = actualUserDerivativeResponseFirst.ids;
        const actualUserDerivativeResponseSecond = await miltonStorageDai.getSwapPayFixedIds(
            await userThree.getAddress(),
            0,
            10
        );
        const actualUserDerivativeIdsSecond = actualUserDerivativeResponseSecond.ids;

        expect(
            expectedUserDerivativeIdsLengthFirst,
            `Incorrect first user swap ids length actual: ${actualUserDerivativeIdsFirst.length}, expected: ${expectedUserDerivativeIdsLengthFirst}`
        ).to.be.eq(actualUserDerivativeIdsFirst.length);
        expect(
            expectedUserDerivativeIdsLengthSecond,
            `Incorrect second user swap ids length actual: ${actualUserDerivativeIdsSecond.length}, expected: ${expectedUserDerivativeIdsLengthSecond}`
        ).to.be.eq(actualUserDerivativeIdsSecond.length);
    });
});
